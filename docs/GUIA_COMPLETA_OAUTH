# ğŸ” GuÃ­a Completa de Testing - Vulnerabilidades OAuth2

## ğŸ“‹ Ãndice
1. [PreparaciÃ³n del Entorno](#preparaciÃ³n)
2. [Vulnerabilidad 1: CSRF en OAuth](#vulnerabilidad-1)
3. [Vulnerabilidad 2: Client Secret Expuesto](#vulnerabilidad-2)
4. [Vulnerabilidad 3: ReutilizaciÃ³n de CÃ³digos](#vulnerabilidad-3)
5. [Resumen de Hallazgos](#resumen)

---

## ğŸ› ï¸ PreparaciÃ³n del Entorno {#preparaciÃ³n}

### Requisitos
- âœ… Docker ejecutÃ¡ndose
- âœ… AplicaciÃ³n corriendo en `http://127.0.0.1:5000`
- âœ… Dos navegadores/ventanas:
  - **Navegador 1:** Normal (para el atacante)
  - **Navegador 2:** Modo IncÃ³gnito (para la vÃ­ctima)

### Verificar que el servidor estÃ¡ corriendo

```bash
# En tu terminal
docker ps

# DeberÃ­as ver el contenedor del banco corriendo
# Si no estÃ¡ corriendo:
docker-compose up -d
```

Visita: http://127.0.0.1:5000 - DeberÃ­as ver la pÃ¡gina principal del banco

---

## ğŸ¯ Vulnerabilidad 1: CSRF en OAuth (State no validado) {#vulnerabilidad-1}

### Â¿QuÃ© es?
El parÃ¡metro `state` en OAuth2 previene ataques CSRF. Si no se valida correctamente, un atacante puede:
1. Iniciar un flujo OAuth con **su** cuenta Google
2. Capturar la URL de autorizaciÃ³n
3. EnviÃ¡rsela a la vÃ­ctima
4. Cuando la vÃ­ctima autoriza, **su cuenta bancaria** se vincula a la **cuenta Google del atacante**

### ğŸ“ **PASO A PASO - ExplotaciÃ³n Manual**

#### **FASE 1: Atacante prepara el ataque**

1. **Abre el navegador NORMAL** (serÃ¡ el atacante)

2. **Ve a:** http://127.0.0.1:5000/oauth/init

3. **ObtendrÃ¡s algo como:**
```json
{
  "authorization_url": "http://127.0.0.1:5000/oauth/google/authorize?client_id=banco-app-123456&redirect_uri=http://127.0.0.1:5000/oauth/callback&response_type=code&state=ABC123XYZ&scope=email+profile",
  "state": "ABC123XYZ"
}
```

4. **Copia el `authorization_url`** completo

5. **PÃ©galo en la barra de direcciones** del mismo navegador

6. **Login con la cuenta del ATACANTE:**
   - Email: `hacker@google.com`
   - Password: `hacker123`
   - Presiona "Iniciar SesiÃ³n"

7. **IMPORTANTE:** VerÃ¡s la pantalla de "AutorizaciÃ³n". 
   **NO presiones "Permitir" todavÃ­a**

8. **Copia la URL COMPLETA** de esta pantalla de autorizaciÃ³n. SerÃ¡ algo como:
```
http://127.0.0.1:5000/oauth/google/authorize?client_id=banco-app-123456&redirect_uri=http://127.0.0.1:5000/oauth/callback&state=ABC123XYZ&scope=email+profile&response_type=code
```

#### **FASE 2: VÃ­ctima completa el ataque sin saberlo**

9. **Abre un navegador en MODO INCÃ“GNITO** (serÃ¡ la vÃ­ctima)

10. **Pega la URL** que copiaste del atacante en el paso 8

11. **Login con la cuenta de la VÃCTIMA:**
    - Email: `usuario@google.com`
    - Password: `google123`
    - Presiona "Iniciar SesiÃ³n"

12. **Presiona "Permitir"** en la pantalla de autorizaciÃ³n

#### **RESULTADO DEL ATAQUE:**

âœ… La cuenta bancaria de `usuario@google.com` (vÃ­ctima) quedarÃ¡ vinculada a la sesiÃ³n OAuth que iniciÃ³ `hacker@google.com` (atacante)

âœ… El atacante puede ahora acceder a la cuenta bancaria de la vÃ­ctima

### ğŸ” **Â¿Por quÃ© funciona?**

El cÃ³digo NO valida que el `state` pertenezca a la misma sesiÃ³n/navegador que lo generÃ³:

```python
# âŒ CÃ“DIGO VULNERABLE (app_banco.py lÃ­nea ~450)
# NO HAY VALIDACIÃ“N DEL STATE

# âœ… CÃ“DIGO SEGURO (deberÃ­a tener):
if state not in oauth_states:
    return "Invalid state", 400
    
state_data = oauth_states[state]
if state_data['session_id'] != session.get('_id'):
    return "State belongs to different session - CSRF DETECTED", 400
```

### ğŸ“¸ **Evidencia para tu informe:**

**Captura 1:** URL con el `state` generado por el atacante
**Captura 2:** Pantalla de login como vÃ­ctima
**Captura 3:** Dashboard del banco mostrando cuenta vinculada

---

## ğŸ”‘ Vulnerabilidad 2: Client Secret Expuesto {#vulnerabilidad-2}

### Â¿QuÃ© es?
El `CLIENT_SECRET` es una credencial confidencial que NUNCA debe exponerse pÃºblicamente. Con Ã©l, un atacante puede:
- Obtener tokens de acceso directamente
- Saltarse todo el flujo OAuth
- Suplantar la identidad de la aplicaciÃ³n

### ğŸ“ **PASO A PASO - ExplotaciÃ³n**

#### **FASE 1: Obtener el Client Secret**

1. **Abre tu navegador**

2. **Ve a:** http://127.0.0.1:5000/oauth/info

3. **VerÃ¡s una pÃ¡gina con las credenciales:**
```
CLIENT_ID: banco-app-123456
CLIENT_SECRET: SECRET_SUPER_SECRETO_EXPUESTO_123
JWT_SECRET: jwt_secret_debil
```

4. **Copia el `CLIENT_SECRET`**

#### **FASE 2: Usar el Secret para obtener tokens**

5. **Primero necesitas obtener un cÃ³digo de autorizaciÃ³n:**
   - Ve a: http://127.0.0.1:5000/oauth/init
   - Copia el `authorization_url`
   - Completa el flujo OAuth normal (login + autorizar)
   - En la URL del callback, copia el `code`:
   ```
   http://127.0.0.1:5000/oauth/callback?code=CODIGO_AQUI&state=...
   ```

6. **Ahora usa curl para obtener el token directamente:**

```bash
curl -X POST http://127.0.0.1:5000/oauth/google/token \
  -H "Content-Type: application/json" \
  -d '{
    "code": "TU_CODIGO_AQUI",
    "client_id": "banco-app-123456",
    "client_secret": "SECRET_SUPER_SECRETO_EXPUESTO_123"
  }'
```

7. **RecibirÃ¡s un token vÃ¡lido:**
```json
{
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
  "token_type": "Bearer",
  "expires_in": 86400,
  "user_info": { ... }
}
```

### ğŸ” **Â¿Por quÃ© funciona?**

El `CLIENT_SECRET` estÃ¡:
1. âŒ Hardcodeado en el cÃ³digo fuente (lÃ­nea 18)
2. âŒ Expuesto en una pÃ¡gina web pÃºblica `/oauth/info`
3. âŒ NO estÃ¡ en variables de entorno

```python
# âŒ CÃ“DIGO VULNERABLE
GOOGLE_CLIENT_SECRET = "SECRET_SUPER_SECRETO_EXPUESTO_123"

# âœ… CÃ“DIGO SEGURO (deberÃ­a ser):
import os
GOOGLE_CLIENT_SECRET = os.environ.get('OAUTH_CLIENT_SECRET')
```

### ğŸ“¸ **Evidencia para tu informe:**

**Captura 1:** PÃ¡gina `/oauth/info` mostrando credenciales
**Captura 2:** Terminal con curl obteniendo token
**Captura 3:** Respuesta JSON con el access_token

---

## ğŸ”„ Vulnerabilidad 3: ReutilizaciÃ³n de CÃ³digos OAuth {#vulnerabilidad-3}

### Â¿QuÃ© es?
Los cÃ³digos de autorizaciÃ³n OAuth deberÃ­an usarse **UNA SOLA VEZ** y luego invalidarse. Si no se invalidan, un atacante que intercepte un cÃ³digo puede usarlo mÃºltiples veces.

### ğŸ“ **PASO A PASO - ExplotaciÃ³n**

#### **FASE 1: Obtener un cÃ³digo vÃ¡lido**

1. **Completa un flujo OAuth normal:**
   - Ve a: http://127.0.0.1:5000/oauth/init
   - Copia el `authorization_url`
   - Login con: `test@google.com` / `test123`
   - Autoriza la aplicaciÃ³n

2. **En la URL del callback, verÃ¡s algo como:**
```
http://127.0.0.1:5000/oauth/callback?code=Np8jYGHpDqk&state=XYZ
```

3. **Copia el `code`** (ej: `Np8jYGHpDqk`)

4. **La primera vez funciona:** serÃ¡s redirigido al dashboard

#### **FASE 2: Reutilizar el mismo cÃ³digo**

5. **Cierra la sesiÃ³n** (o usa modo incÃ³gnito)

6. **Construye la URL del callback manualmente:**
```
http://127.0.0.1:5000/oauth/callback?code=Np8jYGHpDqk&state=cualquier_valor
```

7. **PÃ©gala en el navegador y presiona Enter**

8. **RESULTADO:** El cÃ³digo funciona DE NUEVO âŒ

### ğŸ” **Â¿Por quÃ© funciona?**

El cÃ³digo NO elimina ni invalida los cÃ³digos despuÃ©s de usarlos:

```python
# âŒ CÃ“DIGO VULNERABLE (lÃ­nea ~555)
# NO se elimina el cÃ³digo despuÃ©s de usarlo
auth_data = authorization_codes[code]
# ... usa el cÃ³digo ...
# DEBERÃA HACER: del authorization_codes[code]

# Tampoco valida si ya fue usado:
# if auth_data.get('used_count', 0) > 0:
#     return "Code already used", 400
```

### ğŸ“¸ **Evidencia para tu informe:**

**Captura 1:** Primera vez usando el cÃ³digo (exitoso)
**Captura 2:** Segunda vez usando el MISMO cÃ³digo (tambiÃ©n exitoso) âŒ
**Captura 3:** Dashboard mostrando acceso con cÃ³digo reutilizado

---

## ğŸ“Š Resumen de Hallazgos {#resumen}

| # | Vulnerabilidad | Severidad | CVSS | Impacto |
|---|---------------|-----------|------|---------|
| 1 | CSRF en OAuth (State no validado) | ğŸ”´ CrÃ­tica | 9.1 | Secuestro de cuenta, acceso no autorizado |
| 2 | Client Secret Expuesto | ğŸ”´ CrÃ­tica | 9.8 | Bypass OAuth completo, suplantaciÃ³n de identidad |
| 3 | ReutilizaciÃ³n de CÃ³digos OAuth | ğŸŸ  Alta | 7.5 | Replay attacks, acceso mÃºltiple no autorizado |

### ğŸ›¡ï¸ Mitigaciones Recomendadas

#### **Para Vulnerabilidad 1:**
```python
# Validar state en el callback
if state not in oauth_states:
    abort(403, "Invalid state - CSRF detected")
    
state_data = oauth_states[state]
if state_data['session_id'] != session.get('_id'):
    abort(403, "State from different session")
    
if time.time() - state_data['timestamp'] > 300:
    abort(403, "State expired")
    
oauth_states[state]['used'] = True
```

#### **Para Vulnerabilidad 2:**
```python
# Usar variables de entorno
import os
CLIENT_SECRET = os.environ.get('OAUTH_CLIENT_SECRET')

# NUNCA exponer en:
# - CÃ³digo fuente
# - PÃ¡ginas web pÃºblicas
# - JavaScript del frontend
# - Logs o errores
```

#### **Para Vulnerabilidad 3:**
```python
# Invalidar cÃ³digo despuÃ©s del primer uso
if code in authorization_codes:
    auth_data = authorization_codes[code]
    
    # Verificar si ya fue usado
    if auth_data.get('used_count', 0) > 0:
        abort(400, "Authorization code already used")
    
    # Marcar como usado
    auth_data['used_count'] += 1
    
    # Mejor: eliminarlo completamente
    del authorization_codes[code]
```

---

## ğŸ¯ Checklist de Testing

Antes de presentar tu trabajo, verifica:

- [ ] Has probado la Vulnerabilidad 1 con dos navegadores
- [ ] Capturaste evidencia de cada paso
- [ ] Probaste la Vulnerabilidad 2 accediendo a `/oauth/info`
- [ ] Usaste curl o Postman para demostrar Vulnerabilidad 2
- [ ] Probaste reutilizar un cÃ³digo OAuth en Vulnerabilidad 3
- [ ] Documentaste cada hallazgo con capturas
- [ ] Explicaste el impacto de cada vulnerabilidad
- [ ] Propusiste mitigaciones para cada una

---

## ğŸš€ Scripts Automatizados

Para facilitar el testing, usa:

```bash
# Instalar dependencias
pip install requests colorama

# Ejecutar script de testing
python test_oauth_vulnerabilities.py
```

El script te guiarÃ¡ paso a paso por cada vulnerabilidad.

---

## ğŸ“š Referencias

- [OAuth 2.0 RFC 6749](https://tools.ietf.org/html/rfc6749)
- [OAuth 2.0 Threat Model (RFC 6819)](https://tools.ietf.org/html/rfc6819)
- [OWASP OAuth 2.0 Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OAuth2_Cheat_Sheet.html)

---

**Â¿Dudas?** Revisa el cÃ³digo en `app_banco.py` lÃ­neas:
- Vulnerabilidad 1: LÃ­neas 380-420, 540-560
- Vulnerabilidad 2: LÃ­neas 18-20, 350-360
- Vulnerabilidad 3: LÃ­neas 540-580